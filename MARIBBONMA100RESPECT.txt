import pandas as pd
import numpy as np
from binance.client import Client
from datetime import datetime, timedelta
import time
from enum import Enum

class PositionType(Enum):
    LONG = "LONG"
    SHORT = "SHORT"
    FLAT = "FLAT"

class PaperTradeRibbon:
    def __init__(self, symbol='SUIUSDC', initial_balance=100.0, lookback=300):
        self.symbol = symbol
        self.initial_balance = initial_balance
        self.balance = initial_balance
        self.position = PositionType.FLAT
        self.position_size = 0.0
        self.entry_price = 0.0
        self.entry_time = None
        self.client = Client()
        self.lookback = lookback
        
        # Trading statistics
        self.trades = []
        self.wins = 0
        self.losses = 0
        self.total_pnl = 0.0
        self.max_win = 0.0
        self.max_loss = 0.0
        self.win_amounts = []
        self.loss_amounts = []
        
    def get_live_data(self):
        """Get live data from Binance"""
        try:
            klines = self.client.get_klines(
                symbol=self.symbol,
                interval=Client.KLINE_INTERVAL_1SECOND,
                limit=self.lookback
            )
            
            df = pd.DataFrame(klines, columns=[
                'timestamp', 'open', 'high', 'low', 'close', 'volume',
                'close_time', 'quote_asset_volume', 'number_of_trades',
                'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'ignore'
            ])
            
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            df['close'] = df['close'].astype(float)
            return df
            
        except Exception as e:
            print(f"Error fetching data: {e}")
            return self.generate_volatile_data()
    
    def generate_volatile_data(self):
        """Generate volatile sample data"""
        dates = pd.date_range(end=datetime.now(), periods=self.lookback, freq='1S')
        prices = []
        current_price = 1.5
        
        for i in range(self.lookback):
            trend = np.sin(i * 0.1) * 0.001  # Sine wave for trends
            volatility = np.random.normal(0, 0.002)
            current_price += trend + volatility
            current_price = max(0.1, current_price)
            prices.append(current_price)
        
        return pd.DataFrame({
            'timestamp': dates,
            'close': prices
        })
    
    def calculate_ribbons(self, prices):
        """Calculate both regular and anti-ribbons"""
        # Regular ribbon
        regular_periods = [2, 4, 6, 8, 10, 12]
        regular_ribbon = {}
        for period in regular_periods:
            regular_ribbon[f'MA_{period}'] = prices.rolling(window=period, min_periods=1).mean()
        
        # Anti-ribbon
        anti_periods = [3, 5, 7, 9, 11, 13]
        anti_ribbon = {}
        for period in anti_periods:
            # Different calculation for anti-ribbon
            anti_ribbon[f'Anti_MA_{period}'] = prices.rolling(window=period).apply(
                lambda x: (x.mean() * 0.4 + x.median() * 0.6)
            )
        
        return regular_ribbon, anti_ribbon
    
    def calculate_trading_signals(self, df, regular_ribbon, anti_ribbon):
        """Calculate trading signals based on ribbon convergence/divergence"""
        regular_avg = pd.DataFrame(regular_ribbon).mean(axis=1)
        anti_avg = pd.DataFrame(anti_ribbon).mean(axis=1)
        current_price = df['close'].iloc[-1]
        
        # Current values
        current_regular = regular_avg.iloc[-1]
        current_anti = anti_avg.iloc[-1]
        current_spread = current_regular - current_anti
        convergence = abs(current_regular - current_anti)
        
        # Signal strength based on multiple factors
        signals = []
        
        # 1. Convergence signal (strong when ribbons are close)
        if convergence < 0.0005:  # Very close convergence
            signals.append(("STRONG_CONVERGENCE", 2.0))
        elif convergence < 0.001:  # Moderate convergence
            signals.append(("CONVERGENCE", 1.0))
        
        # 2. Price position relative to ribbons
        if current_price > current_regular and current_price > current_anti:
            signals.append(("PRICE_ABOVE_BOTH", 1.5))
        elif current_price < current_regular and current_price < current_anti:
            signals.append(("PRICE_BELOW_BOTH", 1.5))
        
        # 3. Ribbon crossover momentum
        if len(regular_avg) > 10:
            # Check if spread is increasing/decreasing
            spread_trend = current_spread - (regular_avg.iloc[-5] - anti_avg.iloc[-5])
            if abs(spread_trend) > 0.0003:
                signals.append(("MOMENTUM", 1.2 if spread_trend > 0 else -1.2))
        
        # 4. Recent price momentum
        if len(df) > 5:
            price_change = (current_price / df['close'].iloc[-5] - 1) * 100
            if abs(price_change) > 0.1:  # 0.1% change in 5 seconds
                signals.append(("PRICE_MOMENTUM", 1.1 if price_change > 0 else -1.1))
        
        # Calculate overall signal score
        total_score = sum(score for _, score in signals)
        
        # Determine position type
        if total_score > 1.5:
            return PositionType.LONG, total_score, signals, convergence, current_spread
        elif total_score < -1.5:
            return PositionType.SHORT, total_score, signals, convergence, current_spread
        else:
            return PositionType.FLAT, total_score, signals, convergence, current_spread
    
    def calculate_position_size(self, current_price, signal_strength):
        """Calculate position size based on signal strength and risk management"""
        risk_per_trade = 1  # 100% of balance per trade
        base_size = self.balance * risk_per_trade / current_price
        
        # Adjust size based on signal strength
        strength_multiplier = min(abs(signal_strength) / 3.0, 1.0)
        return base_size * strength_multiplier
    
    def enter_position(self, position_type, current_price, signal_strength):
        """Enter a new position"""
        if self.position != PositionType.FLAT:
            self.close_position(current_price)  # Close existing position first
        
        self.position_size = self.calculate_position_size(current_price, signal_strength)
        self.entry_price = current_price
        self.entry_time = datetime.now()
        self.position = position_type
        
        print(f"ðŸŸ¢ ENTER {position_type.value} | Size: {self.position_size:.4f} | "
              f"Price: {current_price:.6f} | Signal: {signal_strength:.2f}")
    
    def close_position(self, current_price):
        """Close current position and record PnL"""
        if self.position == PositionType.FLAT:
            return
        
        # Calculate PnL
        if self.position == PositionType.LONG:
            pnl = (current_price - self.entry_price) * self.position_size
        else:  # SHORT
            pnl = (self.entry_price - current_price) * self.position_size
        
        # Update balance
        self.balance += pnl
        self.total_pnl += pnl
        
        # Calculate time in position
        time_in_position = (datetime.now() - self.entry_time).total_seconds()
        
        # Record trade
        trade = {
            'entry_time': self.entry_time,
            'exit_time': datetime.now(),
            'position_type': self.position,
            'entry_price': self.entry_price,
            'exit_price': current_price,
            'size': self.position_size,
            'pnl': pnl,
            'time_in_position': time_in_position
        }
        self.trades.append(trade)
        
        # Update statistics
        if pnl > 0:
            self.wins += 1
            self.win_amounts.append(pnl)
            self.max_win = max(self.max_win, pnl)
        else:
            self.losses += 1
            self.loss_amounts.append(pnl)
            self.max_loss = min(self.max_loss, pnl)
        
        print(f"ðŸ”´ EXIT {self.position.value} | PnL: ${pnl:.4f} | "
              f"Time: {time_in_position:.1f}s | Balance: ${self.balance:.4f}")
        
        # Reset position
        self.position = PositionType.FLAT
        self.position_size = 0.0
        self.entry_price = 0.0
        self.entry_time = None
    
    def get_unrealized_pnl(self, current_price):
        """Calculate unrealized PnL for current position"""
        if self.position == PositionType.FLAT:
            return 0.0
        
        if self.position == PositionType.LONG:
            return (current_price - self.entry_price) * self.position_size
        else:  # SHORT
            return (self.entry_price - current_price) * self.position_size
    
    def print_second_by_second_data(self, current_price, position_signal, signal_strength, signals, convergence, spread, unrealized_pnl):
        """Print detailed data every second"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        
        print(f"\n[{timestamp}] PRICE: {current_price:.6f} | POSITION: {self.position.value} | SIGNAL: {position_signal.value}")
        print(f"    Signal Strength: {signal_strength:.2f} | Convergence: {convergence:.6f} | Spread: {spread:.6f}")
        print(f"    Balance: ${self.balance:.4f} | Unrealized PnL: ${unrealized_pnl:.4f}")
        
        # Print active signals
        if signals:
            signal_names = [f"{name}({score:.1f})" for name, score in signals]
            print(f"    Active Signals: {', '.join(signal_names)}")
        
        # Print position details if in trade
        if self.position != PositionType.FLAT:
            time_in_pos = (datetime.now() - self.entry_time).total_seconds()
            print(f"    Entry Price: {self.entry_price:.6f} | Time in Position: {time_in_pos:.1f}s")
    
    def print_performance_stats(self):
        """Print comprehensive performance statistics"""
        print("\n" + "="*50)
        print("PERFORMANCE SUMMARY")
        print("="*50)
        
        total_trades = len(self.trades)
        win_rate = (self.wins / total_trades * 100) if total_trades > 0 else 0
        
        avg_win = np.mean(self.win_amounts) if self.win_amounts else 0
        avg_loss = np.mean(self.loss_amounts) if self.loss_amounts else 0
        avg_trade_time = np.mean([t['time_in_position'] for t in self.trades]) if self.trades else 0
        
        profit_factor = abs(sum(self.win_amounts) / sum(self.loss_amounts)) if self.loss_amounts else float('inf')
        
        print(f"Starting Balance: ${self.initial_balance:.2f}")
        print(f"Current Balance: ${self.balance:.2f}")
        print(f"Total PnL: ${self.total_pnl:.4f}")
        print(f"Return: {(self.balance/self.initial_balance-1)*100:.2f}%")
        print(f"Total Trades: {total_trades}")
        print(f"Win Rate: {win_rate:.1f}%")
        print(f"Wins: {self.wins} | Losses: {self.losses}")
        print(f"Max Win: ${self.max_win:.4f} | Max Loss: ${self.max_loss:.4f}")
        print(f"Average Win: ${avg_win:.4f} | Average Loss: ${avg_loss:.4f}")
        print(f"Profit Factor: {profit_factor:.2f}")
        print(f"Average Time in Position: {avg_trade_time:.1f}s")
        
        # Recent trades
        if self.trades:
            print(f"\nLast 5 Trades:")
            for trade in self.trades[-5:]:
                pnl_color = "ðŸŸ¢" if trade['pnl'] > 0 else "ðŸ”´"
                print(f"  {pnl_color} {trade['position_type'].value}: ${trade['pnl']:.4f} "
                      f"({trade['time_in_position']:.1f}s)")
    
    def run_paper_trading(self):
        """Run paper trading simulation indefinitely"""
        print("Starting Paper Trading...")
        print("="*50)
        print(f"Symbol: {self.symbol}")
        print(f"Initial Balance: ${self.initial_balance}")
        print("Running indefinitely... Press Ctrl+C to stop")
        print("="*50)
        
        iteration_count = 0
        
        try:
            while True:
                iteration_count += 1
                
                # Get fresh data
                df = self.get_live_data()
                
                # Calculate ribbons
                regular_ribbon, anti_ribbon = self.calculate_ribbons(df['close'])
                
                # Get current price
                current_price = df['close'].iloc[-1]
                
                # Calculate trading signals
                position_signal, signal_strength, signals, convergence, spread = self.calculate_trading_signals(
                    df, regular_ribbon, anti_ribbon
                )
                
                # Get unrealized PnL
                unrealized_pnl = self.get_unrealized_pnl(current_price)
                
                # PRINT DATA EVERY SECOND
                self.print_second_by_second_data(current_price, position_signal, signal_strength, 
                                               signals, convergence, spread, unrealized_pnl)
                
                # Manage positions
                if self.position == PositionType.FLAT:
                    # Consider entering new position
                    if position_signal != PositionType.FLAT:
                        self.enter_position(position_signal, current_price, signal_strength)
                
                else:
                    # Manage existing position
                    # Check exit conditions - ONLY EXIT WHEN SIGNAL REVERSES
                    if (position_signal == PositionType.FLAT or 
                        (self.position == PositionType.LONG and position_signal == PositionType.SHORT) or
                        (self.position == PositionType.SHORT and position_signal == PositionType.LONG)):
                        
                        self.close_position(current_price)
                
                time.sleep(1)  # Wait 1 second between iterations
                
        except KeyboardInterrupt:
            print("\nStopping paper trading...")
        
        # Close any open position
        if self.position != PositionType.FLAT:
            self.close_position(self.get_live_data()['close'].iloc[-1])
        
        # Print final performance
        self.print_performance_stats()

def main():
    # Initialize paper trader
    trader = PaperTradeRibbon(symbol='SUIUSDC', initial_balance=100.0, lookback=200)
    
    # Run indefinitely
    trader.run_paper_trading()

if __name__ == "__main__":
    main()